.globl fact	           /* Ignore everything beginning with a "." *//* This file contains IA32 assembly-language implementations of three
 * basic, very common math operations.
 */

    .text

/*====================================================================
 * int f1(int x, int y)
 */
.globl f1 ## This function returns min of two ints.
f1:
	pushl	%ebp             ## Save frame pointer
	movl	%esp, %ebp  
	movl	8(%ebp), %edx ## Load first argument into %edx
	movl	12(%ebp), %eax ## Load second argument into %eax
	cmpl	%edx, %eax ## Compare first and second argument 
	cmovg	%edx, %eax ## If %eax > %edx, move %edx to %eax
	popl	%ebp ## Replace from pointer
	ret


/*====================================================================
 * int f2(int x) ## Computes absolute value of x
 */
.globl f2
f2:
	pushl	%ebp         ## Save frame pointer
	movl	%esp, %ebp
	movl	8(%ebp), %eax ## Load first argument into %eax
	movl	%eax, %edx ## Copy first argument into %edx
	sarl	$31, %edx  ## Preserve sign bit of edx; remove other bits
	xorl	%edx, %eax ## Set sign of eax to 0 if not already
	subl	%edx, %eax ## If first arguement is positive, 
	## do nothing, otherwise get two's complement
	popl	%ebp  ## Replace frame pointer
	ret


/*====================================================================
 * int f3(int x) ## Returns 1 if x is >0, else 0 
 */
.globl f3
f3:
	pushl	%ebp  ## Save frame pointer
	movl	%esp, %ebp 
	movl	8(%ebp), %edx ## Load first arguement into %edx
	movl	%edx, %eax ## Copy first argument to %eax
	sarl	$31, %eax  ## Preserve sign bit of edx; remove other bits
	testl	%edx, %edx ## Check to see if edx is zero
	movl	$1, %edx ## Store 1 in edx
	cmovg	%edx, %eax ## If edx was >0 in the check, return 1, else return 0.
	popl	%ebp ## Replace frame pointer
	ret


.text
	.align 4
fact:
	pushl %ebp         /* Push old base pointer. */
	movl %esp,%ebp     /* Current stack is new base. */
	cmpl $0,8(%ebp)    /* See if arg equal zero. */
	jne fact_continue  /* If not, continue. */
	movl $1,%eax       /* Else returnesult is one. */
	jmp fact_return
	.align 4           /* This is generated by the compiler to align */
                           /* code so that the CPU can process it better. */
fact_continue:
	movl 8(%ebp),%eax  /* The argument arg. */
	subl $1,%eax       /* Compute arg-1 for recursive call. */
	pushl %eax         /* Push arg-1 onto stack. */
	call fact          /* Make recursive call. */
fact_resume:		
	imull 8(%ebp),%eax /* Upon return multiply result by arg. */
	                   /* Result ends up in return register (eax). */
	jmp fact_return    /* We had to align return as a branch target. */
	                   /* This jumps around alignment space. */
	.align 4
fact_return:
	movl %ebp,%esp     /* Pop local stack. */
	popl %ebp          /* Pop old base of frame. */
	ret
